
##创建进程有4种主要事件
1.系统初始化
2.执行了正在运行的进程所调用的进程创建系统调用
3.用户请求创建一个新进程
4.一个批处理作业的初始化

##进程的终止
1.正常退出（自愿的）
2.出错退出（自愿的）
3.严重错误（非自愿的）
4.被其他进程杀死（非自愿的）

##进程的3种状态
1.运行态（该时刻进程实际占用CPU）
2.就绪态（可运行，但因为其他进程正在运行而暂时停止）
3.阻塞态（除非某种外部事件发生，否则不可运行）

##3种状态的转换
运行态->就绪态/阻塞态 
就绪态->运行态
阻塞态->就绪态

##进程表（Process Table）
为实现进程模型，操作系统维护一张表格，即进程表。

#线程
线程和进程一样 也有运行,就绪,阻塞和终止状态.
有一个常用的线程调用 thread_yield,它允许线程自动放弃CPU从而让另一个线程运行.
因为,线程不同于进程,线程无法利用时钟中断强制线程让出CPU.

有2种主要的方法实现线程包:在用户空间中和在内核中.
用户空间管理线程时,每个进程需要有其专用的线程表(Thread Table),用来跟踪进程中的线程.
线程与进程的一个关键的差别:线程完成调用时,线程的信息保存在线程表中,进而,它可以调用
线程调度程序来选择另一个要运行的线程.保存该线程的过程和调度程序都只是本地程序,所以
启动它们比进行内核调用效率更高.同时也不需要陷阱(Trap指令),不需要上下文切换(Context Switching)
也不需要对内存高速缓存进行刷新,这就使得线程的调度非常快捷.
用户级线程还有一个优点就是允许每个进程都有自己的调度算法.



##进程间的通信
进程间的通信主要会涉及到3个问题。
1.一个进程如何把消息传递给另一个
2.确保两个或更多的进程在关键活动中不会出现交叉（如 飞机订票系统中2个进程试图争夺最后一个座位）
3.正确的执行顺序（如 进程A产生数据，而进程B打印该数据。 那么进程B在打印之前必须等待）

上面3个问题中2和3对于线程来说也同样适用。（因为线程共享地址空间，所以传递消息比较容易）


竞争条件：两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为竞争条件（race condition）
竞争条件需要避免。可以通过互斥（mutual exclusion）来避免竞争条件
互斥：以某种手段确保当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作。
对共享内存进行访问的程序片段称作临界区域（critical region）或临界区（critical section）

对于多进程的设计，比较好的解决方案需满足以下4个条件
1.任何两个进程不能同时处于其临界区
2.不应对CPU的速度和数量做任何假设
3.临界区外运行的进程不得阻塞其他进程
4.不得使进程无期限等待进入临界区

#关于互斥，有以下几种方案：
1.屏蔽中断
主要实现原理：当进程刚刚进入临界区后，立即屏蔽所有中断，并在要离开前再打开中断。
※CPU只有在发生时钟中断或其他中断时候才会进行进程切换。
事实证明该方案不好：
首先，将屏蔽中断的权利交给用户进程是不明智的，若用户进程忘记打开屏蔽中断，则整个系统会因此终止。（如上述，进程之间无法进行切换）。
而且在多CPU中，屏蔽中断只对执行disable指令的CP有效，其他的CPU仍将继续运行并可以访问共享内存。

2.锁变量
设想有一个共享锁变量，初始值为0.
如果有一个进程想要进入其临界区，它首先测试这把锁，如果该锁值为0，则该进程将其值设置为1，并进入临界区。
如果这把锁的值为1，则该进程将等待直到其值变为0.


3.严格轮换法
忙等待：（Busy Wait） 连续测试一个变量直到某个值出现为止。 这种方式浪费CPU时间，应该避免。
只有在有理由认为等待时间是非常短的情形下，才使用忙等待，用户忙等待的锁，称作自旋锁（Spin Lock）。
如果两个进程的执行速度相差很多的情况下，可能会产生临界区外的进程阻塞其他进程的运行。


4.Peterson解法







