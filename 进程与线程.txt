
##创建进程有4种主要事件
1.系统初始化
2.执行了正在运行的进程所调用的进程创建系统调用
3.用户请求创建一个新进程
4.一个批处理作业的初始化

##进程的终止
1.正常退出（自愿的）
2.出错退出（自愿的）
3.严重错误（非自愿的）
4.被其他进程杀死（非自愿的）

##进程的3种状态
1.运行态（该时刻进程实际占用CPU）
2.就绪态（可运行，但因为其他进程正在运行而暂时停止）
3.阻塞态（除非某种外部事件发生，否则不可运行）

##3种状态的转换
运行态->就绪态/阻塞态 
就绪态->运行态
阻塞态->就绪态

##进程表（Process Table）
为实现进程模型，操作系统维护一张表格，即进程表。

#线程
线程和进程一样 也有运行,就绪,阻塞和终止状态.
有一个常用的线程调用 thread_yield,它允许线程自动放弃CPU从而让另一个线程运行.
因为,线程不同于进程,线程无法利用时钟中断强制线程让出CPU.

有2种主要的方法实现线程包:在用户空间中和在内核中.
用户空间管理线程时,每个进程需要有其专用的线程表(Thread Table),用来跟踪进程中的线程.
线程与进程的一个关键的差别:线程完成调用时,线程的信息保存在线程表中,进而,它可以调用
线程调度程序来选择另一个要运行的线程.保存该线程的过程和调度程序都只是本地程序,所以
启动它们比进行内核调用效率更高.同时也不需要陷阱(Trap指令),不需要上下文切换(Context Switching)
也不需要对内存高速缓存进行刷新,这就使得线程的调度非常快捷.
用户级线程还有一个优点就是允许每个进程都有自己的调度算法.



##进程间的通信
进程间的通信主要会涉及到3个问题。
1.一个进程如何把消息传递给另一个
2.确保两个或更多的进程在关键活动中不会出现交叉（如 飞机订票系统中2个进程试图争夺最后一个座位）
3.正确的执行顺序（如 进程A产生数据，而进程B打印该数据。 那么进程B在打印之前必须等待）

上面3个问题中2和3对于线程来说也同样适用。（因为线程共享地址空间，所以传递消息比较容易）


竞争条件：两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为竞争条件（race condition）
竞争条件需要避免。可以通过互斥（mutual exclusion）来避免竞争条件
互斥：以某种手段确保当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作。









